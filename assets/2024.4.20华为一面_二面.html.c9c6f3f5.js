import{_ as n}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as a,c as p,a as s}from"./app.6c1a7a4b.js";const l={},i=s(`<h1 id="_2024-04-20华为技术一面-技术二面" tabindex="-1"><a class="header-anchor" href="#_2024-04-20华为技术一面-技术二面" aria-hidden="true">#</a> 2024.04.20华为技术一面+技术二面</h1><h3 id="华为技术一面" tabindex="-1"><a class="header-anchor" href="#华为技术一面" aria-hidden="true">#</a> 华为技术一面</h3><p>主要内容：</p><ul><li><p>Java的⼀些基础知识</p></li><li><p>项⽬问题</p></li><li><p>⼿撕代码</p><h4 id="java基础知识" tabindex="-1"><a class="header-anchor" href="#java基础知识" aria-hidden="true">#</a> Java基础知识</h4></li></ul><ol><li>哪些存储容器是线程安全的？</li></ol><p>同步容器类：使⽤了synchronized</p><ul><li>Vector</li><li>HashTable</li></ul><p>并发容器类：</p><ul><li>ConcurrentHashMap：分段</li><li>CopyOnWriteArrayList：写时复制</li><li>CopyOnWriteArraySet：写时复制</li></ul><p>Queue</p><ul><li>ConcurrentLinkedQueue：使⽤⾮阻塞式的⽅式实现的基于链接节点的⽆界的线程安全队列，性</li><li>能⾮常好。（java.util.concurrent.BlockingQueue 接⼝代表了线程安全的队列）</li><li>ArrayBlockingQueue：基于数组的有界阻塞队列</li><li>LinkedBlockingQueue：基于链表的有界阻塞队列</li><li>PriorityBolckingQueue：表⽰优先级的⽆界阻塞队列，即该阻塞队列中的元素可⾃动排序。默认</li><li>情况下，元素采⽤⾃然升序</li><li>DelayQueue：⼀种延时获取元素的⽆界阻塞队列</li><li>SynchronousQueue：不存储元素的阻塞队列。每个put操作必须等待⼀个take操作，否则不能继</li><li>续添加元素；内部起始没有任何⼀个元素，容量是0</li></ul><p>Deque接⼝定义了双向队列，双向队列允许在队列头和尾部继续⼊队出队操作</p><ul><li>ArrayDeque：基于数组的双向⾮阻塞队列</li><li>LinkedBlockingDeque：基于链表的双向阻塞队列</li><li>Sorted容器</li><li>dakkk（仅供参考）ConcurrentSkipListMap：是TreeMap的线程安全版本</li><li>ConcurrentSkipListSet：是TreeSet的线程安全版本</li></ul><ol start="2"><li>StringBuffer 和 StringBuilder 有线程安全的吗 （没听清，以为是多线程的东西，能回答上来的）</li></ol><ul><li>String 中的对象是不可变的，也就可以理解为常量，线程安全。</li><li>StringBuffer 对⽅法加了同步锁或者对调⽤的⽅法加了同步锁，所以是线程安全的。</li><li>StringBuilder 并没有对⽅法进⾏加同步锁，所以是⾮线程安全的。</li></ul><ol start="3"><li>项⽬中使⽤多线程的场景 (目前写过的项目没有使用过多线程！！！)</li></ol><ul><li>多线程是⼀种允许多个任务同时执⾏的技术。它通过将任务分解为更⼩的部分并在不同的线程上</li><li>运⾏这些部分来实现。</li><li>这可以提⾼程序的性能，尤其是当任务是CPU密集型或涉及⼤量IO时</li><li>在⼯作中，有多种场景可以使⽤多线程，⼀下是⼀些最常⻅的例⼦：</li><li>后台任务：后台任务是通常在⽤⼾不知不觉中运⾏的任务，例如：⽂件上传或数据处理，使⽤</li><li>多线程可以将这些任务与主应⽤程序分开，这样他们就不会阻塞主应⽤程序并导致其⽆响应</li><li>⽹络请求：当⽤⼾从⽹站或应⽤程序请求数据时，会发出⽹络请求，使⽤多线程可以同时处理</li><li>多个⽹络请求，从⽽提⾼响应速度</li></ul><ol start="4"><li>多线程使⽤过程中，需要注意的点是什么？ (不熟)</li></ol><ul><li>死锁</li><li>线程安全</li><li>并发</li></ul><ol start="5"><li>多线程中的各项资源这么处理呢？ (不熟)</li></ol><ul><li>同步关键字：synchronized关键字是 Java 中最常⽤的同步机制，它通过 ⼀次只有⼀个线程执⾏代</li><li>码块或⽅法来保护共享资源</li><li>锁：java 提供了显⽰锁机制，例如：ReentrantLock 和 ReadWriteLock，这些锁⽐ synchronized</li><li>关键字更灵活，但也更复杂</li><li>原⼦操作：Java 提供了原⼦操作，例如 AtomicInteger 和 AtomicLong，原⼦操作是不可分割的操</li><li>作，可以确保共享资源的更新不会出现数据竞争</li><li>线程安全类：Java 提供了许多线程安全类，例如 Vector 和 HashMap，这些类内部使⽤了同步机</li><li>制来保护共享资源，因此⽆需显⽰同步</li></ul><ol start="6"><li>Synchronized中 类锁 和 对象锁的区别？ (以前学习过，忘记了)</li></ol><ul><li><p>dakkk（仅供参考）类锁和对象锁都是 Java 中的同步机制，⽤于控制对共享资源的访问，但是，他们之间还存在⼀定</p></li><li><p>的区别</p><p>获取⽅式</p></li><li><p>类锁是通过 synchronized 关键字 修饰静态⽅法或代码块来获取的</p></li><li><p>对象锁是通过 synchronized 关键字修饰实⼒⽅法或代码块来获取的，也可以通过显⽰锁（例如</p></li><li><p>ReentrantLock）来获取</p><p>作⽤范围</p></li><li><p>类锁是整个类，意味着同⼀时刻只能有⼀个线程持有类锁</p></li><li><p>对象锁的作⽤范围是单个对象，意味着同⼀时刻可以有多线线程持有不同的对象锁</p><p>同步效果</p></li><li><p>类锁⽤于同步对静态⽅法和静态变量的访问。静态⽅法和静态变量是和类关联的，⽽不是与特</p><p>定对象关联的。因此，类锁可以确保同⼀时刻只能有⼀个线程执⾏静态⽅法或访问静态变量</p></li><li><p>对象锁⽤于同步对实例⽅法和实例变量的访问。实例⽅法和实例变量是与特定对象关联的，因</p></li><li><p>此，对象锁可以确保同⼀时刻只能有⼀个线程执⾏同⼀个对象的实例⽅法或访问同⼀个对象的实例变量</p></li></ul><ol start="7"><li>maven⼯程和java⼯程的区别？ (用自己的语言说出来了)</li></ol><p>项⽬结构</p><p>​ maven</p><ul><li>具有标准化的项⽬结构，所有项⽬⽂件都位于特定的⽬录中，这使得maven⼯程易于理解和维护</li><li>使⽤基于 XML 的配置⽂件（pom.xml）来定义项⽬的构建过程。可以⾃动下载依赖项，编译代码，打包应⽤程序等</li><li>具有强⼤的依赖管理功能，可以⾃动下载、安装和管理项⽬所需的依赖项</li></ul><p>​ java</p><ul><li>可以任意定义，这可能会导致难以理解和维护</li><li>通常需要使⽤其他的构建根据，例如 Ant 或 Gradle 来定义构建过程，这些根据可能⽐maven 更复杂</li><li>⼿动管理依赖，可能会导致依赖项冲突和其他问题</li></ul><p>可移植性</p><p>maven⼯程可移植，可以在任何具有 maven安装的环境下运⾏</p><p>java⼯程的可移植性可能取决于所使⽤的构建⼯具和其他依赖项</p><ol start="8"><li>类的加载机制清楚吗？ (背过，说不清楚！！！)</li></ol><p>dakkk（仅供参考）类从加载到虚拟机中开始，直到卸载为⽌，它的整个⽣命周期包括了：加载、验证、准备、解</p><p>析、初始化、使⽤和卸载这7个阶段。其中，验证、准备和解析这三个部分统称为连接（linking）</p><ul><li>1.<mark>加载</mark>：查找和导⼊class⽂件</li><li>2.<mark>验证</mark>：保证加载类的准确性</li><li>3.<mark>准备</mark>：为类变量分配内存并设置类变量初始值</li><li>4.<mark>解析</mark>：把类中的符号引⽤转换为直接引⽤</li><li>5.<mark>初始化</mark>：对类的静态变量，静态代码块执⾏初始化操作</li><li>6.<mark>使⽤</mark>：JVM 开始从⼊⼝（main）⽅法开始执⾏⽤⼾的程序代码</li><li>7.<mark>卸载</mark>：当⽤⼾程序代码执⾏完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运⾏的 JVM 也退出内存</li></ul><p>9.什么是双亲委派模型？及其好处 (背过，说不清楚！！！)</p><p>如果⼀个类加载器收到了类加载的请求，它⾸先<mark>不会⾃⼰尝试加载这个类</mark>，⽽是把这请求委</p><p>派给⽗类加载器去完成，每⼀个层次的类加载器都是如此</p><p>因此所有的加载请求最终都应该委派到顶层的启动类加载器中，只有当⽗类加载器返回⾃⼰⽆法</p><p>完成这个加载请求（它的搜索返回中没有找到所需的类）时，⼦类加载器才会尝试⾃⼰去加载</p><p>好处：</p><p>第⼀、通过双亲委派机制可以<mark>避免</mark>某⼀个<mark>类被重复加载</mark>，当⽗类已经加载后则⽆需重复</p><p>加载，保证唯⼀性。</p><p>第⼆、为了<mark>安全</mark>，保证<mark>类库API不会被修改</mark></p><p>10.什么是反射，其优缺点？应⽤场景 (看过，说不清楚！！！)</p><p>通过反射你可以获取任意⼀个类的所有属性和⽅法，你还可以调⽤这些⽅法和属性。</p><ol><li><p>优点：反射可以让我们的代码更加灵活、为各种框架提供开箱即⽤的功能提供了便利;</p></li><li><p>缺点：</p></li></ol><p>性能开销：反射操作⽐直接访问类、字段和⽅法的性能要低。这是因为反射需要在运⾏时进⾏</p><p>额外的解析和检查</p><p>安全隐患：反射允许代码执⾏⼀些在正常情况下不允许的操作。例如访问私有成员、修改类定</p><p>义等。这可能会导致安全漏洞，例如未经授权地访问或修改数据</p><p>代码可读性：会使代码更加复杂和难以理解，因为它增加了额外的抽象层</p><p>编译时检查缺失：由于反射是在运⾏时进⾏的，编译器⽆法检查许多反射相关的错误，例如类</p><p>名拼写错误、⽅法名错误等，只能在运⾏时发现这些错误，有可能会导致程序崩溃</p><ol start="3"><li>像 Spring/Spring Boot、MyBatis 等等框架中都⼤量使⽤了反射机制</li></ol><p>dakkk（仅供参考）</p><ol start="4"><li><p>且这些框架使⽤了⼤量的AOP（动态代理），AOP的实现也依赖反射</p></li><li><p>提⾼代码的重⽤性，允许程序以通⽤的⽅式处理不同的类、字段和⽅法。例如，假设⼀个程序需</p></li></ol><p>要验证多个对象的属性值是否为空，使⽤反射，程序可以编写⼀个通⽤⽅法来验证任意对象的任意属性</p><ol start="11"><li>开发中⽤到了那些设计模式？ (不熟)</li></ol><p>设计模式（design pattern）是解决软件设计中常⻅问题的通⽤解决⽅案，它为开发⼈员提供了⼀套结果验证的⽅案，⽤于解决常⻅的软件设计问题，提⾼代码的可复⽤性、可维护性和可拓展性</p><p>根据功能和⽤途、设计模式可以分为以下三⼤类：</p><ul><li>创建型模式（creational Patterns）：⽤于常⻅对象的模式</li><li>结构性模式（Structural Patterns）：⽤于描述如何将类或对象组合成更⼤的结构的模式</li><li>⾏为型模式（Behavioral Patterns）：⽤于描述对象之间如何通信和交互的模式</li></ul><p>开发中常⽤的设计模式有:</p><ul><li>创建型模式</li><li>单例模式（Singleton Pattern）：确保⼀个类只有⼀个实例，并提供⼀个全局访问点</li><li>⼯⼚⽅法模式（Factory Method Pattern）：定义⼀个创建对象的接⼝，让⼦类决定实例化哪个类</li><li>抽象⼯⼚模式（Abstract Factory Pattern）：提供⼀个创建多个相关或依赖对象的接⼝</li><li>建造者模式（BUilder Pattern）：将⼀个复杂对象的创建分为多个步骤，并⽤不同的对象封装这些步骤</li><li>结构型模式</li><li>适配器模式（Adapter Pattern）：将⼀个类的接⼝转换为另⼀个类所需的接⼝</li><li>桥接模式（Bridge Pattern）：将⼀个对象的接⼝和实现解耦，使得⼆者可以独⽴变化</li><li>组合模式（Composite Pattern）：将多个对象组合成树形结构，并向客⼾提供统⼀的接⼝</li><li>装饰者模式（Decorator Pattern）：为⼀个对象添加新的功能，保持原有功能不变。</li></ul><p>12.JVM的垃圾回收算法知道吗？</p><ul><li><p>标签-清除算法：最早使⽤的垃圾回收⽅法之⼀，该⽅法⾸先标记所有可达的对象，然后回收所有</p></li><li><p>未标记的对象，效率⽐较低，需要扫描整个堆空间，内存碎⽚⽐较⼤</p></li><li><p>复制算法：将所有可达的对象复制到⼀个新的内存区域，然后回收旧的内存区域。效率⽐较⾼，但需要⼤量的内存空间</p></li><li><p>标签-整理算法：结合标签-清除算法和压缩法的有点，先标记所有可达的对象，然后将这些对象</p></li><li><p>移动到堆空间的⼀端，并回收剩余的内存空间。⽬前最常⽤的垃圾回收⽅法之⼀。</p></li><li><p>dakkk（仅供参考）分代收集算法：将堆空间划分为年轻代和⽼年代，年轻代包含新创建的对象，⽼年代包含存活时</p></li><li><p>间较⻓的⼤型对象。年轻代的回收频率⽐极⾼（java8使⽤复制算法），⽼年代的垃圾回收频率⽐较低，可以提⾼垃圾回收的效率</p></li><li><ol start="13"><li>⼀些算法的原理</li></ol></li><li><p>动态规划算法（Dynamic Programming Algorithm）：⼀种通过将问题分解为⼦问题，并重复利</p></li><li><p>⽤⼦问题的解决来解决问题的算法。动态规划算法常⽤于解决具有重叠⼦问题的问题。</p></li><li><p>贪⼼算法（Greedy Algorithm）：⼀种通过在每⼀步做出局部最优选择的算法，通常⽤于解决 NP难问题</p></li><li><p>并查集：⼀种⽤于处理集合的数据结构，并查集⽀持两种操作，查找和合并，通常⽤于解决连通性问题</p></li><li><p>快排基本原理：通过分治法将⼀个数组划分成两个数组，然后递归地对⼦数组进⾏排序</p></li></ul><ol start="14"><li>优化mysql的⽅法</li></ol><p>使⽤分布式数据库</p><p>使⽤负载均衡</p><p>使⽤监控⼯具</p><ol start="15"><li>Redis缓存击穿、穿透、雪崩 (击穿和穿透区分了好久)</li></ol><p>缓存穿透是指 缓存和数据库中都没有的数据 ，⽽⽤⼾不断发起请求。</p><ol><li><p>接⼝层增加校验，如⽤⼾鉴权校验，id做基础校验，id&lt;=0的直接拦截；</p></li><li><p>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对 写为 key-null，缓存有</p></li></ol><p>效时间可以设置短点，如30s（设置太⻓会导致正常情况也没法使⽤）。这样可以防⽌攻击⽤⼾反</p><p>复⽤同⼀个id暴⼒攻击；</p><ol start="3"><li>布隆过滤器。bloomfilter就类似于⼀个HashSet，⽤于快速判断某个元素是否存在于集合中，其</li></ol><p>典型的应⽤场景就是快速判断⼀个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键</p><p>就在于hash算法和容器⼤⼩</p><p>缓存击穿是指 缓存中没有但数据库中有的数据 （⼀般是缓存时间到期），这时由于并发⽤⼾特别多，</p><p>同时读缓存没有读到数据，⼜同时去数据库读取数据，引起数据库压⼒瞬间增⼤，造成过⼤压⼒。</p><ol><li><p>热点数据⽀持续期，持续访问的数据可以不断续期，避免因为过期失效⽽被击穿</p></li><li><p>（互斥锁）发现缓存失效，重建缓存加互斥锁，当线程查询缓存发现缓存不存在就会尝试加锁，</p></li></ol><p>线程争抢锁，拿到锁的线程就会查询数据库，然后重建缓存，争抢锁失败的线程，可以加⼀个睡</p><p>眠然后循环重试。</p><ol start="3"><li>（逻辑过期）把过期时间设置在value中，查询缓存中的数据时，如果发现逻辑时间已过期，尝试</li></ol><p>获取锁，开启⼀个异步的⽅法进⾏缓存的更新操作，先返回过期的数据。</p><p>dakkk（仅供参考）缓存雪崩，是指⼤量的应⽤请求因为异常⽆法在Redis缓存中进⾏处理，像雪崩⼀样，直接打到数据</p><p>库。</p><p>缓存中 数据大批量过期，而查询数据量巨大，引起数据库压力过大甚至宕机</p><ol><li><p>缓存数据的过期时间设置随机，分⽀同⼀时间⼤量数据过期现象发⽣</p></li><li><p>重建缓存加互斥锁，当线程拿到缓存发现缓存不存在就会尝试加锁，线程争抢锁，拿到锁的线程</p></li></ol><p>就会进⾏查询数据库，然后重建缓存，争抢锁失败的线程，可以加⼀个睡眠然后循环重试</p><ol start="16"><li>Vue常⻅的钩⼦函数，以及作⽤？\`(就说了onMounted和onUnmounted)\`\`</li></ol><p>onMounted() 注册⼀个回调函数，在组件挂载完成后执⾏。</p><p>onUpdated() 注册⼀个回调函数，在组件因为响应式状态变更⽽更新其 DOM 树之后调⽤。</p><p>onUnmounted() 注册⼀个回调函数，在组件实例被卸载之后调⽤。</p><p>onBeforeMount() 注册⼀个钩⼦，在组件被挂载之前被调⽤。</p><p>onBeforeUpdate() 注册⼀个钩⼦，在组件即将因为响应式状态变更⽽更新其 DOM 树之前调</p><p>⽤。</p><p>onBeforeUnmount() 注册⼀个钩⼦，在组件实例被卸载之前调⽤。</p><h5 id="项目拷打-伙伴匹配和api项目" tabindex="-1"><a class="header-anchor" href="#项目拷打-伙伴匹配和api项目" aria-hidden="true">#</a> 项⽬拷打（伙伴匹配和API项⽬）</h5><p>伙伴匹配项⽬的规模有多⼤，有⼏个⼈开发，都分别是什么⻆⾊</p><p>按照开发的流程，说⾃⼰之前的公司⽐较⼩，就只有 前端、后端、运维这些⼈，⼀共⼗⼏个⼈</p><p>这两个项⽬你做了那些优化呢？遇到的难题有吗？</p><p>这⾥乱答的，背了⼀些相关的⾯试题</p><p>难题因为没做这两个项⽬，就没怎么回答上来</p><p>优化就说了这些</p><h5 id="伙伴匹配" tabindex="-1"><a class="header-anchor" href="#伙伴匹配" aria-hidden="true">#</a> 伙伴匹配</h5><p>使⽤knife4j+swagger，优化接⼝调试</p><p>使⽤Stream API + Lambda ，简化集合处理</p><p>⾃主编写Dockerfile，实现⾃动化镜像构建及容器部署</p><p>API项⽬</p><p>使⽤Spring Cloud Gateway 作为API⽹关</p><p>使⽤Spring Boot Starter 开发客⼾端SDK</p><p>balabala</p><p>dakkk（仅供参考）⼿撕算法</p><p>因为说了⾃⼰只对数据结构相关的算法⽐较熟悉，就出了⼀个⼆叉树的题⽬</p><p>\\104. ⼆叉树的最⼤深度 - ⼒扣（LeetCode）</p><p>搞清楚什么是深度和⾼度</p><p>深度：任意⼀个节点到root节点的距离</p><p>⾼度：任意⼀个节点到叶⼦节点的距离</p><p>后序遍历（左右中）：适⽤于求树的⾼度，因为通过左右节点，可以将结果返回给当前的⽗节点，实</p><p>现了从底部往上的⼀个计数过程</p><p>前序遍历（中左右）：适⽤于求树的深度，往下遍历⼀次，就深度+1，从⽽不断遍历，向下探索</p><p>明⾯上来说是求最⼤深度，<mark>本质上是求根节点的⾼度</mark>，所以我们使⽤<mark>后序遍历</mark></p><p>递归三部曲：</p><p>返回值int，⼊参节点</p><p>终⽌条件，⼊参的节点为null</p><p>遍历顺序，左右中，左右为递归，<mark>中为取左右中的最⼤⾼度+1</mark></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>


<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> leftHeight <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> rightHeight <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftHeight<span class="token punctuation">,</span>rightHeight<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="华为技术二面" tabindex="-1"><a class="header-anchor" href="#华为技术二面" aria-hidden="true">#</a> 华为技术二面</h3><p>主要内容：</p><ul><li>⾃我介绍</li><li>介绍⼯作项⽬（简历上的项⽬）</li><li>常规⼋股</li><li>⼿撕算法</li></ul><p>⾃我介绍</p><p>之前参考（隔壁）星球⼤佬 我就是贺生啊 的⽂章)写过⼀个模版，主要有以下内容</p><p>个⼈介绍（学历、性格、爱好、突出喜欢专研编程相关的技术）</p><p>个⼈成⻓（校招说学习经历，社招说⼯作经历，还是要突出编程相关的经历）</p><p>补充社招的内容：通过⾃⼰的实际项⽬来说成⻓！！</p><p>1 介绍⼯作项⽬（主要）</p><p>社招的兄弟，脸⽪厚点，把⾃⼰写的项⽬当作公司的项⽬来说就好了</p><p>主要问的内容如下，问的⽐较多就不说了：</p><p>先说⼀遍项⽬的的流程（⾃⼰做的流程肯定知道吧，不过专注于后端/前端，别前后端都说）</p><p>再说项⽬中遇到的问题，以及如何解决的（不细说了）</p><p>最后说项⽬⾃⼰做了那些优化（不细说了）</p><p>个⼈思考/建议：</p><p>做项⽬的时候，思考⼀下别⼈为什么⽤这个东西，有什么好处，可以⽤其他⾃⼰知道的吗？</p><p>遇到bug的时候，记录下来，回顾⼀下</p><p>也是在做项⽬的时候，记录⾃⼰感觉可以优化的点，然后在做项⽬的时候进⾏优化，或者做完项</p><p>⽬的时候再优化</p><p>关键点： 上述的过程都要做⽂档沉淀！！！以后问到了就会回答了</p><p>dakkk（仅供参考）常规⼋股（这次问的少，不过⽐较深⼊）</p><ol><li>存储容器是线程安全的？ （上次问过了，这次准确答出）</li></ol><p>同步容器类：使⽤了synchronized</p><p>Vector</p><p>HashTable</p><p>并发容器类：</p><p>ConcurrentHashMap：分段</p><p>CopyOnWriteArrayList：写时复制</p><p>CopyOnWriteArraySet：写时复制</p><p>Queue</p><p>ConcurrentLinkedQueue：使⽤⾮阻塞式的⽅式实现的基于链接节点的⽆界的线程安全队列，性</p><p>能⾮常好。（java.util.concurrent.BlockingQueue 接⼝代表了线程安全的队列）</p><p>ArrayBlockingQueue：基于数组的有界阻塞队列</p><p>LinkedBlockingQueue：基于链表的有界阻塞队列</p><p>PriorityBolckingQueue：表⽰优先级的⽆界阻塞队列，即该阻塞队列中的元素可⾃动排序。默认</p><p>情况下，元素采⽤⾃然升序</p><p>DelayQueue：⼀种延时获取元素的⽆界阻塞队列</p><p>SynchronousQueue：不存储元素的阻塞队列。每个put操作必须等待⼀个take操作，否则不能继</p><p>续添加元素；内部起始没有任何⼀个元素，容量是0</p><p>Deque接⼝定义了双向队列，双向队列允许在队列头和尾部继续⼊队出队操作</p><p>ArrayDeque：基于数组的双向⾮阻塞队列</p><p>LinkedBlockingDeque：基于链表的双向阻塞队列</p><p>Sorted容器</p><p>ConcurrentSkipListMap：是TreeMap的线程安全版本</p><p>ConcurrentSkipListSet：是TreeSet的线程安全版本</p><ol start="2"><li>Springboot你了解吗？经常⽤哪些注解呢？ 按照自己的理解说了</li></ol><p>先回答了什么是Springboot</p><p>dakkk（仅供参考）Spring Boot 已经建⽴在现有 spring 框架之上。使⽤ spring 启动，我们避免了之前我们必须做</p><p>的所有样板代码和配置。因此，Spring Boot 可以 帮助我们以最少的⼯作量，更加健壮地使⽤</p><p>现有的 Spring 功能。</p><p>⼜回答了Springboot的优点</p><p>减少开发，测试时间和努⼒。</p><p>使⽤ JavaConfig 有助于避免使⽤ XML。</p><p>避免⼤量的 Maven 导⼊和各种版本冲突。</p><p>通过提供默认值快速开始开发。</p><p>没有单独的 Web 服务器需要。这意味着你不再需要启动 Tomcat，Glassfish 或其他任何东</p><p>西。</p><p>需要更少的配置 因为没有 web.xml ⽂件</p><p>最后回答了⼀些常⽤注解</p><p>⼤家都⽤过的，就不多说了！</p><ol start="3"><li>Mybatis的⼀⼆级缓存知道吗？ 按照自己的理解说了</li></ol><p>⼀ 级 缓 存 ： 基 于 PerpetualCache的 HashMap 本 地 缓 存 ， 其 存 储 作 ⽤ 域 为 SqlSession, 各 个</p><p>SqlSession之间的缓存相互隔离，当Session flush或close之后，该SqlSession中的所有Cache就将</p><p>清空，MyBatis默认打开⼀级缓存</p><p>⼆级缓存与⼀级缓存其机制相同，默认也是采⽤PerpetualCache,HashMap存储，不同之处在于其</p><p>存储作⽤域为Mapper(Namespace),可以在多个SqlSession之间共享，并且可⾃定义存储源，如</p><p>Ehcache。默认不打开⼆级缓存，要开启⼆级缓存，使⽤⼆级缓存属性类需要实现Serializable序</p><p>列化接⼝（可⽤来保存对象的状态），可在它的映射⽂件中配置</p><p>当开启⼆级缓存后，数据的查询执⾏的流程就是⼆级缓存-&gt;⼀级缓存-&gt;数据库。</p><p>缓存更新机制：当某⼀个作⽤域(⼀级缓存Session/⼆级缓存Mapper)进⾏了C/U/D操作（创建、更</p><p>新、删除）后，默认该作⽤域下所有select中的缓存将被clear。</p><ol start="4"><li>Mybatis你是如何理解的呢？\`按照⾃⼰的理解说了</li></ol><p>先说了什么是Mybatis</p><p>MyBatis是⼀个ORM（对象关系映射）框架，它内部封装了JDBC,开发时只需要关注SQL语句本</p><p>⾝，不需要花费精⼒去处理加载驱动，创建连接，创建statement:等复杂的过程。开发⼈员不</p><p>需要编写原⽣态sql,可以严格控制Sq执⾏性能，灵活度⾼。</p><p>MyBatis可以使⽤ml或者注解来配置映射原⽣信息，将PO]O映射成数据库中的记录，避免了⼏</p><p>乎所有的]DBC代码和⼿动设置的参数以及获取结果集。</p><p>⼜说了Mybatis 的优点</p><p>dakkk（仅供参考）基于SQL语句编程，⽐较灵活，不会对应⽤程序或数据库现有设计造成影响，SQL写在XML</p><p>⾥，解除sql语句和业务代码的耦合，便于统⼀管理，⽽且语句在XML⾥，可以复⽤</p><p>与传统JDBC相⽐，减少了很多代码量，消除了⼤量代码冗余，不需要⼿动开关SqlSession的连</p><p>接</p><p>使⽤JDBC驱动连接数据库，所以JDBC⽀持的数据库，Mybatis都⽀持</p><p>与Spring完美集成</p><p>提供映射标签，⽀持对象与数据库ORM字段关系映射；对象关系也可以映射</p><p>Mybatis的缺点</p><p>SQL语句依赖，需要开发⼈员具备⼀定的SQL知识，另外，如果数据库模式发⽣变化，还需要</p><p>⼿动修改SQL语句</p><p>XML配置⽂件冗⻓，会导致⼀些维护问题，如果还使⽤注解配置，代码可能会混乱</p><p>缺乏⾃动化创建，相⽐其他ORM框架，Mybatis不⽀持⾃动创建表和字段</p><p>最后⼜聊了聊Mybatis Plus</p><p>主要是什么是MP</p><p>MP有什么优点和缺点</p><p>具体的应⽤场景就不多说了，懂得，哈哈哈哈</p><ol start="5"><li>Redis中的list和map数据类型了解吗？说说应⽤场景 按照自己的理解说了</li></ol><p>因为伙伴匹配项⽬⽤redis作为旁路缓存了，主要⽤的是String类型的数据，就问了问其他数据结构有</p><p>⽤过吗？</p><p>我说没⽤过，不过了解他的底层结构，也知道应⽤的场景</p><p>List</p><p>底层结构：</p><p>3.2版本之前，List对象有两种编码⽅式，⼀种是ZIPLIST，另⼀种是LINKEDLIST</p><p>列表对象保存的所有字符串对象 长度都小于64字节 或者 列表对象元素 个数少于512个 ，则</p><p>使⽤ZIPLIST，否则使⽤LINKEDLIST</p><p>ZIPLIST（压缩列表）没有细说了</p><p>3.2版本就引⼊了QUICKLIST。QUICKLIST其实就是ZIPLIST和LINKEDLIST的结合体</p><p>当数据较少的时候，QUICKLIST的节点就只有⼀个，此时其实相当于就是⼀个ZIPLIST</p><p>当数据很多的时候，则同时利⽤了ZIPLIST和LINKEDLIST的优势</p><p>使⽤场景</p><p>dakkk（仅供参考）朋友圈点赞：发朋友圈的⼈⽤key表⽰，点赞的⼈为value,点赞操作对应rpush,取消点赞操作可</p><p>以对应lrem。评论信息可以通过list去查询关系型数据库。</p><p>消息队列：list类型的lpop和rpush（或者反过来，lpush和rpop）能实现队列的功能，故⽽可</p><p>以⽤Redis的list类型实现简单的点对点的消息队列。不推荐在实战中这么使⽤，因为现在已经</p><p>有Kafka、NSQ、RabbitMQ等成熟的消息队列了，它们的功能已经很完善了。</p><p>排⾏榜：list类型的lrange命令可以分⻚查看队列中的数据。可每隔⼀段时间计算⼀次的排⾏榜</p><p>存储在list类型中的数据；</p><p>⼀般要求顺序的业务中，都⽤list来实现；</p><p>Map/Hash</p><p>底层结构</p><p>压缩列表：</p><ol><li><p>Hash对象保存的所有值和键的⻓度都⼩于64字节；</p></li><li><p>Hash对象元素个数少于512个。</p></li></ol><p>上述两个条件任何⼀条都不满⾜，编码结构就⽤HASHTABLE</p><p>HASHTABLE没有细说了，底层结构（字段），渐进式扩容，缩容没提了</p><p>应⽤场景：</p><p>购物⻋：⽤⼾的id为key，商品id为field，商品数量为value</p><p>存储对象：</p><p>因为有些使⽤使⽤String（key-value=json）的时候，对象的某个属性频繁修改，每次修改</p><p>都需要将整个对象重新JSON序列化，不够灵活；</p><p>但是我们使⽤HASH，将经常发⽣变化的属性，存放在value⾥，json对象放在field中，就可</p><p>以灵活的修改属性了，如：商品的价格、销量、关注数、评价数</p><p>3 ⼿撕算法</p><ol start="5"><li>最⻓回⽂⼦串 - ⼒扣（LeetCode）</li></ol><p>这次是直接给了个leetcode原题的链接了</p><p>分析了⼀下这个代码的实现思路</p><p>还有其他⽅式解决这个问题吗？ 没答出来</p><p>直接贴代码</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>

<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">longestPalindrome</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token operator">/</span> 思路：中心拓展法

<span class="token operator">/</span> <span class="token operator">&gt;</span> 中心向两边拓展，分奇数和偶数的情况，只要相同就继续拓展

<span class="token operator">/</span> <span class="token operator">&gt;</span> 直到不同为止

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i <span class="token operator">+</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>

<span class="token operator">/</span> max记录最长回文串的长度，start记录最长回文串的起始位置

<span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token operator">/</span> 分奇数和偶数的情况

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">;</span>j <span class="token operator">+</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>

<span class="token operator">/</span> 左指针

<span class="token keyword">int</span> left <span class="token operator">=</span> i<span class="token punctuation">;</span>

<span class="token operator">/</span> 右指针

<span class="token keyword">int</span> right <span class="token operator">=</span> i<span class="token operator">+</span>j<span class="token punctuation">;</span>

<span class="token operator">/</span> 循环从中心向两边拓展

<span class="token keyword">while</span>（left <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">&amp;</span> right<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>

s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

left <span class="token operator">-</span> <span class="token punctuation">;</span>

right <span class="token operator">+</span> <span class="token punctuation">;</span>

<span class="token punctuation">}</span>

<span class="token operator">/</span> 更新最长回文串的长度和起始位置

<span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token operator">-</span><span class="token number">1</span><span class="token operator">&gt;</span>max<span class="token punctuation">)</span><span class="token punctuation">{</span>

<span class="token operator">/</span> 长度

max <span class="token operator">=</span> right <span class="token operator">-</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token operator">/</span> 起始位置

start <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>start<span class="token operator">+</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,266),e=[i];function t(o,r){return a(),p("div",null,e)}const d=n(l,[["render",t],["__file","2024.4.20华为一面+二面.html.vue"]]);export{d as default};
