import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as a,c as r,a as i}from"./app.6c1a7a4b.js";const d={},h=i('<h1 id="_2024-4-8快手一面" tabindex="-1"><a class="header-anchor" href="#_2024-4-8快手一面" aria-hidden="true">#</a> 2024.4.8快手一面</h1><h3 id="那里用的docker-为什么用docker-为什么不用虚拟机" tabindex="-1"><a class="header-anchor" href="#那里用的docker-为什么用docker-为什么不用虚拟机" aria-hidden="true">#</a> 那里用的Docker，为什么用Docker？为什么不用虚拟机？</h3><p>部署基础环境的时候（如seata，jenkins），很方便。部署Java环境的时候，先把jar包构建出一个容器然后进行部署，好处是安装和部署软件都很方便，并且容器之间可以隔离，Docker 容器相比传统的虚拟机更加轻量级，不需要完整的操作系统。</p><h3 id="docker的优缺点-网络模式" tabindex="-1"><a class="header-anchor" href="#docker的优缺点-网络模式" aria-hidden="true">#</a> Docker的优缺点，网络模式</h3><p>容器适用不同的环境，移植性好。比虚拟机来说可以快速部署和启动。资源之间相互隔离，同时共享宿主机的内核资源。Dockerfile镜像构建和容器运行来确保环境的一致性。轻松实现水平扩展，通过编排工具k8s自动管理容器，版本控制和回滚</p><p>缺点性能会比原生低一点，网络配置复杂。</p><p>网络模式：</p><ol><li>bridge模式，可以和宿主机以及其他容器通信</li><li>host模式，使用宿主机的网络，直接暴露，无法通过端口隔离</li></ol><h3 id="docker部署服务的流程" tabindex="-1"><a class="header-anchor" href="#docker部署服务的流程" aria-hidden="true">#</a> Docker部署服务的流程</h3><ol><li>编写一个Dockfile文件，主要是拉取Java8镜像，然后把jar包放到容器里，再启动</li><li>使用<code>docker build</code>构建出一个镜像</li><li>启动容器<code>docker run</code>或者<code>docker-compose up -d </code></li></ol><h3 id="gpg密钥对" tabindex="-1"><a class="header-anchor" href="#gpg密钥对" aria-hidden="true">#</a> GPG密钥对</h3><p>分公钥和私钥。公钥加密私钥解密，私钥签名公钥验签。GPG专注于加密解密验证签名，SSH的RSA专注几远程登录。</p><h3 id="https的过程" tabindex="-1"><a class="header-anchor" href="#https的过程" aria-hidden="true">#</a> HTTPs的过程</h3><p>HTTPS比HTTP协议安全，因为HTTP是明文传输，而HTTPS是加密传输，加密过程中使用了三种加密手段，分别是证书，对称加密和非对称加密。HTTPS相比于HTTP多了一层SSL/TSL。</p><ol><li>证书加密,服务器使用证书加密之前需要去证书颁发机构申请服务器证书，会把本地证书发送给客户端，客户端验证服务器的身份</li><li>对称加密：客户端和服务器通信事业对称加密，使用同一私钥进行，加密算法公开，私钥不可以泄漏</li><li>非对称加密：客户端使用公钥加密，服务器用私钥解密</li></ol><p>HTTPs的整体流程：</p><p>1.客户端想服务器发起HTTPS的请求，连接到服务器的443端口；</p><p>2.服务器将非对称加密的公钥传递给客户端，以证书的形式回传到客户端</p><p>3.服务器接受到该公钥进行验证，就是验证2中证书，如果有问题，则HTTPS请求无法继续；如果没有问题，则上述公钥是合格的。（第一次HTTP请求）客户端这个时候随机生成一个私钥，成为client key,客户端私钥，用于对称加密数据的。使用前面的公钥对client key进行非对称加密；</p><p>4.进行二次HTTP请求，将加密之后的client key传递给服务器；</p><p>5.服务器使用私钥进行解密，得到client key,使用client key对数据进行对称加密</p><p>6.将对称加密的数据传递给客户端，客户端使用非对称解密，得到服务器发送的数据，完成第二次HTTP请求。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3cf28afee71670667e8853d4091e1290.png" alt="img"></p><h3 id="tsl四次握手" tabindex="-1"><a class="header-anchor" href="#tsl四次握手" aria-hidden="true">#</a> TSL四次握手</h3><ol><li>第一次，客户端发送Client Hello消息根服务器打招呼，带着客户端的TSL版本，密码套件列表，随机数（用来服务器生成对称加密密钥的材料）</li><li>第二次，服务端收到Client Hello后，会确认TSL版本是否支持，从密码套件中选择一个，生成随机数，然后将这些信息发送给客户端Server Hello</li><li>第三次，客户端生成新的随机数，用服务器的公钥加密改随机数通过Client Key Exchange发送给服务端，服务端收到后，会用私钥来解密得到随机数，这样就有了三个随机数。双方根据三个随机数生成会话密钥，客户端发送Change Cipher Spec来告诉服务端加密发送，再发送Encrypted Handshake Message（Finishd）把之前所有发送的数据做个<strong>摘要</strong>，再用会话密钥（master secret）加密一下，让服务器做个验证验证加密通信「是否可用」和「之前握手信息是否有被中途篡改过」。</li><li>第四次，服务器也是同样的操作，发「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」消息，如果双方都验证加密和解密没问题，那么握手正式完成。</li></ol><h3 id="项目中使用spring事务了吗-啥场景需要事务" tabindex="-1"><a class="header-anchor" href="#项目中使用spring事务了吗-啥场景需要事务" aria-hidden="true">#</a> 项目中使用spring事务了吗，啥场景需要事务？</h3><p>多步骤数据库操作，跨数据库操作发生异常，需要回滚</p><h3 id="mysql的索引数据结构是什么样的" tabindex="-1"><a class="header-anchor" href="#mysql的索引数据结构是什么样的" aria-hidden="true">#</a> MYSQL的索引数据结构是什么样的？</h3><p>B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是按主键顺序存放的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。</p><p>B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，所以B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次。</p><h3 id="b-树和b树的区别" tabindex="-1"><a class="header-anchor" href="#b-树和b树的区别" aria-hidden="true">#</a> B+树和B树的区别</h3><p>对于 B 树,只有叶子节点保存数据,内部节点仅存索引值,不适合范围查找。</p><h3 id="什么是回表" tabindex="-1"><a class="header-anchor" href="#什么是回表" aria-hidden="true">#</a> 什么是回表</h3><p>现在有两个索引，主键索引和二级索引，也就是有两个B+树</p><ul><li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li><li>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</li></ul><p>如果要根据二级索引查询某个数据，会先去二级索引的B+树叶子结点找到主键索引，再根据主键索引回表查询到真实的数据，也就是主键对应的那个B+树的叶子结点的数据。</p><h3 id="联合索引" tabindex="-1"><a class="header-anchor" href="#联合索引" aria-hidden="true">#</a> 联合索引</h3><p>使用联合索引时，存在最左匹配原则，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。</p>',38),l=[h];function c(n,o){return a(),r("div",null,l)}const p=e(d,[["render",c],["__file","2024.4.8快手一面.html.vue"]]);export{p as default};
