import{_ as a}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as e,c as r,a as h}from"./app.6c1a7a4b.js";const d={},n=h(`<h1 id="字节-技术中台-校招-java一面" tabindex="-1"><a class="header-anchor" href="#字节-技术中台-校招-java一面" aria-hidden="true">#</a> 字节-技术中台 -校招-Java一面</h1><h2 id="自我介绍环节" tabindex="-1"><a class="header-anchor" href="#自我介绍环节" aria-hidden="true">#</a> <strong>自我介绍环节</strong></h2><h2 id="先做两道算法题" tabindex="-1"><a class="header-anchor" href="#先做两道算法题" aria-hidden="true">#</a> <strong>先做两道算法题</strong></h2><pre><code>     k个一组反转链表(15min)
     手动构造链表和输入输出,力扣原题
</code></pre><h2 id="问实习项目-那个慢查询怎么做的" tabindex="-1"><a class="header-anchor" href="#问实习项目-那个慢查询怎么做的" aria-hidden="true">#</a> <strong>问实习项目,那个慢查询怎么做的?</strong></h2><h2 id="简述mysql主从复制" tabindex="-1"><a class="header-anchor" href="#简述mysql主从复制" aria-hidden="true">#</a> <strong>简述MySQL主从复制</strong></h2><h2 id="binlog是怎么用的-有几种格式" tabindex="-1"><a class="header-anchor" href="#binlog是怎么用的-有几种格式" aria-hidden="true">#</a> <strong>binlog是怎么用的?有几种格式?</strong></h2><h2 id="你刚才提到有这么多不同的格式" tabindex="-1"><a class="header-anchor" href="#你刚才提到有这么多不同的格式" aria-hidden="true">#</a> <strong>你刚才提到有这么多不同的格式?</strong></h2><p>为什么?避免uuid()等不同函数导致的主库和从库数据不同、以及申请自增主键的产生的主库和从库数据不一致的问题</p><h2 id="主库和从库个数一般怎么配置" tabindex="-1"><a class="header-anchor" href="#主库和从库个数一般怎么配置" aria-hidden="true">#</a> <strong>主库和从库个数一般怎么配置?</strong></h2><p>说了一主三从</p><h2 id="索引底层的数据结构" tabindex="-1"><a class="header-anchor" href="#索引底层的数据结构" aria-hidden="true">#</a> <strong>索引底层的数据结构?</strong></h2><h2 id="你在实习的时候给表加索引-会锁表对吧-有没有一种办法你给一个表上锁-但是不影响其他事务对这个表的读和写" tabindex="-1"><a class="header-anchor" href="#你在实习的时候给表加索引-会锁表对吧-有没有一种办法你给一个表上锁-但是不影响其他事务对这个表的读和写" aria-hidden="true">#</a> 你在实习的时候给表加索引,会锁表对吧?有没有一种办法你给一个表上锁,但是不影响其他事务对这个表的读和写?</h2><p>这个的话不知道,瞎说的 目前不太了解这种机制,但是如果我来实现的话，我会仿造Redis里边那个AOF文件重写的思路，大概是这样的:就是将原来的表fork()一份,然后之后的读写请求都先写到这张临时表中,等到加索引的事务结束了,然后将临时表的数据再刷回到原表中</p><h2 id="你提到了将临时表的数据刷回到原表中-你有没有想过有线程安全问题呢" tabindex="-1"><a class="header-anchor" href="#你提到了将临时表的数据刷回到原表中-你有没有想过有线程安全问题呢" aria-hidden="true">#</a> <strong>你提到了将临时表的数据刷回到原表中,你有没有想过有线程安全问题呢?</strong></h2><p>这个的话主要看刷表操作是怎么实现的,像AOF的实现就是直接替换AOF文件</p><p>如果是MySQL的话,我觉得可以直接替换.ibd文件</p><h2 id="追问-替换-ibd文件这个过程-会导致事务无法读写吗" tabindex="-1"><a class="header-anchor" href="#追问-替换-ibd文件这个过程-会导致事务无法读写吗" aria-hidden="true">#</a> <strong>追问:替换.ibd文件这个过程,会导致事务无法读写吗?</strong></h2><h2 id="如果表特别大-你光是fork-的时间都超过了加锁和解锁的时间-怎么办" tabindex="-1"><a class="header-anchor" href="#如果表特别大-你光是fork-的时间都超过了加锁和解锁的时间-怎么办" aria-hidden="true">#</a> <strong>如果表特别大,你光是fork()的时间都超过了加锁和解锁的时间,怎么办?</strong></h2><pre><code>….不会了
</code></pre><h2 id="binlog可以实现持久化吗-mysql中还有哪些日志" tabindex="-1"><a class="header-anchor" href="#binlog可以实现持久化吗-mysql中还有哪些日志" aria-hidden="true">#</a> binlog可以实现持久化吗?MySQL中还有哪些日志</h2><h2 id="假设mysql提交事务之前崩溃了-怎么恢复" tabindex="-1"><a class="header-anchor" href="#假设mysql提交事务之前崩溃了-怎么恢复" aria-hidden="true">#</a> 假设MySQL提交事务之前崩溃了,怎么恢复?</h2><h2 id="说说两阶段提交协议" tabindex="-1"><a class="header-anchor" href="#说说两阶段提交协议" aria-hidden="true">#</a> 说说两阶段提交协议</h2><h2 id="实习的那个项目有没有分库分表之类的操作-埋下伏笔" tabindex="-1"><a class="header-anchor" href="#实习的那个项目有没有分库分表之类的操作-埋下伏笔" aria-hidden="true">#</a> <strong>实习的那个项目有没有分库分表之类的操作(埋下伏笔)</strong></h2><h2 id="如果让你设计一张表-你会考虑什么呢" tabindex="-1"><a class="header-anchor" href="#如果让你设计一张表-你会考虑什么呢" aria-hidden="true">#</a> <strong>如果让你设计一张表,你会考虑什么呢?</strong></h2><pre><code>主键
查询条件要加索引
尽量使用char而不是varchar
NOT NULL DEFAULT
数据库三范式
</code></pre><h2 id="细说数据库三范式-开发中是不是铁律一定要遵守的" tabindex="-1"><a class="header-anchor" href="#细说数据库三范式-开发中是不是铁律一定要遵守的" aria-hidden="true">#</a> 细说数据库三范式?开发中是不是铁律一定要遵守的?</h2><h2 id="场景-10wtps-可以加中间件-问你如何缓冲压力-避免压力全部打到一个mysql集群上" tabindex="-1"><a class="header-anchor" href="#场景-10wtps-可以加中间件-问你如何缓冲压力-避免压力全部打到一个mysql集群上" aria-hidden="true">#</a> 场景:10WTPS,可以加中间件,问你如何缓冲压力,避免压力全部打到一个MySQL集群上?</h2><p>思路:使用Redis缓存来缓冲一部分的压力,可以将MySQL中部分数据提前缓存到MySQL中，让流量打到Redis上</p><h2 id="追问-你用这个redis-是只用来接收读请求吗" tabindex="-1"><a class="header-anchor" href="#追问-你用这个redis-是只用来接收读请求吗" aria-hidden="true">#</a> 追问:你用这个Redis,是只用来接收读请求吗?</h2><p>不是的,10WTPS一旦打到单机的MySQL上去就会挂,这种情况下最好让Redis即接收读请求和写请求,这里的话使用的策略是叫做 写回策略,原理和操作系统的PageCache差不多 就是我们的业务无论是读请求和写请求都去操作缓存,一旦做了写的操作,就将这个缓存设置为脏数据,然后我们开一个服务,这个服务会定期将脏数据刷回到数据库</p><h2 id="追问-注意10wtps-如果都是写请求-而你的mysql只有1w的处理能力-那你那个刷脏的时间和频率要怎么设计" tabindex="-1"><a class="header-anchor" href="#追问-注意10wtps-如果都是写请求-而你的mysql只有1w的处理能力-那你那个刷脏的时间和频率要怎么设计" aria-hidden="true">#</a> 追问:注意10WTPS,如果都是写请求,而你的MySQL只有1w的处理能力,那你那个刷脏的时间和频率要怎么设计?</h2><p>其实这里面试官就在引导我增加MySQL的实例来提高QPS了…当时脑袋闷闷的,还是在说Redis 刷脏的这个线程不要超过MySQLTPS限制即可</p>`,33),i=[n];function s(t,o){return e(),r("div",null,i)}const f=a(d,[["render",s],["__file","字节-技术中台 -校招-Java一面.html.vue"]]);export{f as default};
