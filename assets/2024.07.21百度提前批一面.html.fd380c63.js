import{_ as o}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as p,c as i,b as n,d as s,e as t,a,r as l}from"./app.6c1a7a4b.js";const r={},c=a('<h1 id="_2024-07-21百度提前批一面" tabindex="-1"><a class="header-anchor" href="#_2024-07-21百度提前批一面" aria-hidden="true">#</a> 2024.07.21百度提前批一面</h1><h3 id="_1、自我介绍" tabindex="-1"><a class="header-anchor" href="#_1、自我介绍" aria-hidden="true">#</a> 1、自我介绍</h3><h3 id="_2、hashcode-和equals-方法的关系" tabindex="-1"><a class="header-anchor" href="#_2、hashcode-和equals-方法的关系" aria-hidden="true">#</a> 2、HashCode（）和equals（）方法的关系</h3><p>equals相等的两个对象的hashCode也一定相等，但hashCode相等的两个对象不一定equals相等。</p><h3 id="_3、重载和重写有什么区别" tabindex="-1"><a class="header-anchor" href="#_3、重载和重写有什么区别" aria-hidden="true">#</a> 3、重载和重写有什么区别？</h3><ul><li><p><strong>重载（Overload）</strong>：</p></li><li><ul><li>重载是指在同一个类中，可以定义多个方法具有相同的名称但是参数列表不同（包括参数的类型、顺序和个数）的情况。</li><li>重载方法的返回值类型可以相同也可以不同，但不能仅仅通过返回值类型的不同来区分重载方法。</li></ul></li><li><p><strong>重写（Override）</strong>：</p></li><li><ul><li>重写是指子类可以定义一个与父类中的某个方法具有相同名称、参数列表和返回类型的方法，从而覆盖父类中的方法实现。</li><li>重写方法必须与父类方法具有相同的方法签名（包括方法名、参数列表和返回类型），但可以拥有不同的方法体。</li></ul></li><li></li></ul><h3 id="_4、讲一讲乐观锁和悲观锁" tabindex="-1"><a class="header-anchor" href="#_4、讲一讲乐观锁和悲观锁" aria-hidden="true">#</a> 4、讲一讲乐观锁和悲观锁</h3><ul><li>悲观锁，就是认为在最坏的情况下，每次读取数据的时候，该数据都会被他人修改，所以每次取数据之前，都要加锁。只有拥有该锁的人，才可以对该数据进行操作。其他人要操作该数据的话，必须等到持有锁，才能进行操作。悲观锁适用于“写”操作比较多的情况，在java中，syschronized（重量级锁）和ReentrantLock(重入锁)都是悲观锁，每次只能有一个线程访问。</li><li>乐观锁，就是认为在最好的情况下，每次取数据的时候，他人都不会更改该数据。乐观锁其实并不是真正的锁，乐观锁是一种无锁机制，没有使用锁，但是可以实现线程间的同步。乐观锁试用于多“读”的情况。即资源间竞争较少的情况。这样可以提高cpu的吞吐量。主要有版本号和CAS两种方式实现</li></ul><h3 id="_5、讲一讲cas原理" tabindex="-1"><a class="header-anchor" href="#_5、讲一讲cas原理" aria-hidden="true">#</a> 5、讲一讲CAS原理</h3><p>CAS（Compare-and-Swap，比较并交换）的原理如下：</p><p>它包含三个操作数：内存位置 V、预期原值 A 和新值 B。当执行 CAS 操作时，会先比较内存位置 V 的值是否等于预期原值 A，如果相等，就将该位置的值更新为新值 B；如果不相等，说明在此期间该值已经被其他线程修改了，则不进行更新操作。</p><p>CAS 是一种无锁算法的实现机制，通过硬件指令来保证原子性操作，它在多线程环境下能高效地实现对共享变量的同步操作，是许多并发框架和工具的重要基础。然而，它也存在一些ABA 问题等局限性。</p><h3 id="_6、aba问题-怎么解决" tabindex="-1"><a class="header-anchor" href="#_6、aba问题-怎么解决" aria-hidden="true">#</a> 6、ABA问题，怎么解决</h3><p>ABA 问题是指在使用 CAS 操作时可能出现的一种情况。假设一个共享变量初始值为 A，线程 T1 将其先修改为 B，然后又修改回 A，在这个过程中另一个线程 T2 进行 CAS 操作，它比较时发现值仍然是 A，就认为没有被其他线程修改过而进行了更新操作，但实际上在此期间已经发生了从 A 到 B 再到 A 的变化，这就是 ABA 问题。它可能会导致一些在特定场景下不符合预期的结果。解决办法如下：</p><ol><li><strong>使用版本号</strong>：为数据增加一个版本号字段，每次修改数据时版本号递增，这样就可以区分不同的修改过程，而不仅仅是比较值是否相同。</li><li><strong>添加标记</strong>：可以添加一些额外的标记来标识数据的状态变化过程，而不仅仅依赖于原始数据的值。</li></ol><h3 id="_7、synchroized是什么锁-跟jdk版本关系-jdk8以前和以后有什么区别" tabindex="-1"><a class="header-anchor" href="#_7、synchroized是什么锁-跟jdk版本关系-jdk8以前和以后有什么区别" aria-hidden="true">#</a> 7、synchroized是什么锁？跟JDK版本关系，jdk8以前和以后有什么区别</h3><p><code>synchronized</code>是一种互斥锁。</p><p>在 JDK 8 以前，<code>synchronized</code>主要通过重量级锁来实现，性能开销相对较大。</p><p>在 JDK 8 及以后，对<code>synchronized</code>进行了优化。引入了偏向锁和轻量级锁等机制，在没有激烈竞争的情况下，可以减少锁获取和释放的开销，提高了性能。偏向锁适用于只有一个线程频繁获取锁的场景，轻量级锁则适用于线程交替执行获取锁的情况，当竞争激烈时才会升级为重量级锁。这些优化使得<code>synchronized</code>在很多场景下的表现有了显著提升。</p><h3 id="_8、线程的状态-分别介绍" tabindex="-1"><a class="header-anchor" href="#_8、线程的状态-分别介绍" aria-hidden="true">#</a> 8、线程的状态，分别介绍</h3><p>在操作系统中，线程被视为轻量级的进程，所以<strong>线程状态其实和进程状态是一致的</strong>。</p><ul><li><strong>创建状态(new)</strong>：进程正在被创建，尚未到就绪状态。</li><li><strong>就绪状态(ready)</strong>：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。</li><li><strong>运行状态(running)</strong>：进程正在处理器上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。</li><li><strong>阻塞状态(waiting)</strong>：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li><li><strong>结束状态(terminated)</strong>：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li></ul><p><img src="https://s2.loli.net/2024/07/21/3wTPKyInfHFtJ61.webp" alt="img"></p><p>在Java中：</p><ul><li><strong>新建（New）</strong>：线程刚被创建，还未启动。</li><li><strong>就绪（Runnable）</strong>：线程正在 CPU 上执行。</li><li><strong>阻塞（Blocked）</strong>：线程因等待某个条件（如获取锁、等待 I/O 操作完成等）而暂停执行。</li><li><strong>等待（Waiting）</strong>：线程处于无限期等待状态，需要其他线程唤醒。</li><li><strong>超时等待（Timed_Waiting）</strong>：线程处于有限时间的等待状态，时间到后会自动唤醒或被其他线程唤醒。</li><li><strong>终止（Terminated）</strong>：线程执行完毕或异常终止。</li></ul><p><img src="https://s2.loli.net/2024/07/21/73ibAfUuY4M5VB8.webp" alt="aaa.png"></p><h3 id="_9、出现sql慢查询-怎么排查" tabindex="-1"><a class="header-anchor" href="#_9、出现sql慢查询-怎么排查" aria-hidden="true">#</a> 9、出现SQL慢查询，怎么排查</h3>',27),d={href:"https://blog.csdn.net/qq_48508278/article/details/127043949#:~:text=1%3A%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF",target:"_blank",rel:"noopener noreferrer"},u=a(`<div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token number">1.</span> 开启慢查询日志
<span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">&#39;slow_query_log&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">set</span> <span class="token keyword">global</span> slow_query_log<span class="token operator">=</span><span class="token keyword">on</span><span class="token punctuation">;</span>
<span class="token number">2.</span>更改慢查询阈值
<span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">&#39;long_query_time&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">set</span> long_query_time<span class="token operator">=</span><span class="token number">0.3</span><span class="token punctuation">;</span>
<span class="token number">3.</span> 查看慢查询日志位置
<span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">&#39;slow_query_log_file&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这时候查看日志文件，可以看到慢查询的语句，然后再对语句分析，可以使用explain语句，看是否走索引，没有索引可以加个索引或者优化sql语句，尽量走索引</p><p>回答：</p><ol><li><strong>分析 SQL 语句结构</strong>：检查是否存在复杂的多表连接、不必要的子查询等。</li><li><strong>查看慢查询日志</strong>：确定具体是哪些 SQL 语句执行慢。</li><li><strong>检查索引</strong>：explain看是否缺少合适的索引，或者索引是否失效。</li></ol><h3 id="_10、异常处理相关的注解-怎么定义和捕获全局异常处理器" tabindex="-1"><a class="header-anchor" href="#_10、异常处理相关的注解-怎么定义和捕获全局异常处理器" aria-hidden="true">#</a> 10、异常处理相关的注解，怎么定义和捕获全局异常处理器</h3><p>通过 <code>@ControllerAdvice</code> 注解标记该类为全局异常处理类，然后使用不同的 <code>@ExceptionHandler</code> 来处理特定类型的异常。</p><h3 id="_11、用过springboot中传入参数校验的注解吗" tabindex="-1"><a class="header-anchor" href="#_11、用过springboot中传入参数校验的注解吗" aria-hidden="true">#</a> 11、用过SpringBoot中传入参数校验的注解吗？</h3><p>在 Spring Boot 中常用的参数校验注解有很多，比如：</p><ul><li><code>@NotNull</code>：表示该字段不能为空。</li><li><code>@NotEmpty</code>：表示该字段不能为空字符串或集合不能为空。</li><li><code>@Size(min=, max=)</code>：限制字段的长度范围。</li><li><code>@Min</code>：限制数值的最小值。</li><li><code>@Max</code>：限制数值的最大值。</li></ul><h3 id="_12、算法-有一个数列-求最大的连续子序列值" tabindex="-1"><a class="header-anchor" href="#_12、算法-有一个数列-求最大的连续子序列值" aria-hidden="true">#</a> 12、算法，有一个数列，求最大的连续子序列值</h3>`,10),k={href:"https://leetcode.cn/problems/maximum-subarray/description/",target:"_blank",rel:"noopener noreferrer"},h=a(`<p>动态规划：<code>f[i]=max(f[i-1]+nums[i],nums[i]);</code></p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> n<span class="token operator">=</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> res<span class="token operator">=</span><span class="token operator">-</span><span class="token number">10086</span><span class="token punctuation">;</span>
        <span class="token comment">//f[i]表示以i结尾的最大连续子数组的和 f[i]=max(f[i-1]+nums[i],nums[i]);</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            res<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_13、反问环节" tabindex="-1"><a class="header-anchor" href="#_13、反问环节" aria-hidden="true">#</a> 13、反问环节</h3>`,3);function m(_,b){const e=l("ExternalLinkIcon");return p(),i("div",null,[c,n("p",null,[s("[链接]("),n("a",d,[s("https://blog.csdn.net/qq_48508278/article/details/127043949#:~:text=1%3A查看数据库服务慢查询日志是否开启"),t(e)]),s(" 2%3A开启慢查询日志,3%3A查看慢查询阈值（超过这个时间sql就会被记录在慢查询日志中） 4%3A我们更改一下阈值（因为我们的测试数据插叙时间基本上是不会超过10s的）)")]),u,n("p",null,[n("a",k,[s("https://leetcode.cn/problems/maximum-subarray/description/"),t(e)])]),h])}const f=o(r,[["render",m],["__file","2024.07.21百度提前批一面.html.vue"]]);export{f as default};
