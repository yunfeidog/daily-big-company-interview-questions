import{_ as n}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as a,c as s,a as e}from"./app.6c1a7a4b.js";const t={},d=e(`<h2 id="简短回答" tabindex="-1"><a class="header-anchor" href="#简短回答" aria-hidden="true">#</a> 简短回答</h2><div class="custom-container tip"><p class="custom-container-title">提示</p><p>聚簇索引:</p><p>索引叶子节点存储的是数据行，可以直接访问完整数据。</p><p>每个表只能有一个聚簇索引，通常是主键索引，适合范围查询和排序。</p><p>非聚簇索引:</p><p>索引叶子节点存储的是数据行的主键和对应的索引列，需通过主键才能访问完整的数据行 。</p><p>一个表可以有多个非聚簇索引(称之为非主键索引、辅助索引、二级索引)，适用于快速查找特定列的数据。</p></div><h2 id="详细回答" tabindex="-1"><a class="header-anchor" href="#详细回答" aria-hidden="true">#</a> 详细回答</h2><h2 id="聚簇索引" tabindex="-1"><a class="header-anchor" href="#聚簇索引" aria-hidden="true">#</a> 聚簇索引</h2><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h3><p>聚簇索引（Clustered Index）是一个特殊的索引，它将索引项和数据存储在一起，以减少磁盘读取次数。在InnoDB引擎中，聚簇索引是默认的索引类型，并且每个表都必须有一个聚簇索引。</p><h3 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h3><ol><li>聚簇索引的数据和索引存储在一起，因此可以减少磁盘读取次数，提高查询效率。</li><li>InnoDB中的主键默认是聚簇索引，如果表没有定义主键，InnoDB会选择第一个唯一且非空的索引作为聚簇索引。</li><li>如果表既没有主键也没有合适的唯一索引，InnoDB会自动生成一个隐藏的主键（row_id），作为聚簇索引。</li><li>数据按照聚簇索引的顺序物理存储在表中，所以一个表只能有一个聚簇索引。</li><li>聚簇索引的叶子节点保存的是数据行本身。</li><li>聚簇索引对按主键范围查询的操作非常高效，因为相邻的数据在物理存储上也是相邻的。</li><li>插入和更新操作可能导致页分裂，因此按主键顺序插入数据效率会更高。</li></ol><h2 id="非聚簇索引" tabindex="-1"><a class="header-anchor" href="#非聚簇索引" aria-hidden="true">#</a> 非聚簇索引</h2><h3 id="概念-1" tabindex="-1"><a class="header-anchor" href="#概念-1" aria-hidden="true">#</a> 概念</h3><p>非聚簇索引（Non-Clustered Index），也称为二级索引（Secondary Index），是指索引结构和数据分开存储的索引。在InnoDB中，所有非主键索引都是非聚簇索引。</p><h3 id="特点-1" tabindex="-1"><a class="header-anchor" href="#特点-1" aria-hidden="true">#</a> 特点</h3><ol><li>非聚簇索引的叶子节点不包含完整的数据记录，而是存储了主键值。</li><li>使用非聚簇索引查询时，需要先通过索引找到主键值，然后再通过主键值到聚簇索引中查找完整的数据记录，这个过程被称为&quot;回表&quot;。</li><li>一个表可以有多个非聚簇索引，因为它们只存储索引列和主键值。</li><li>相比聚簇索引，非聚簇索引需要额外的存储空间。</li><li>当查询只涉及到索引列和主键时，可以通过&quot;覆盖索引&quot;避免回表操作，提高查询效率。</li><li>非聚簇索引的维护成本低于聚簇索引，因为页分裂主要发生在聚簇索引中。</li></ol><h2 id="实战分析" tabindex="-1"><a class="header-anchor" href="#实战分析" aria-hidden="true">#</a> 实战分析</h2><h3 id="案例一-索引选择对查询性能的影响" tabindex="-1"><a class="header-anchor" href="#案例一-索引选择对查询性能的影响" aria-hidden="true">#</a> 案例一：索引选择对查询性能的影响</h3><p>假设有一个用户表，结构如下：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> users <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    username <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">UNIQUE</span><span class="token punctuation">,</span>
    email <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    created_at <span class="token keyword">DATETIME</span><span class="token punctuation">,</span>
    <span class="token keyword">INDEX</span> idx_email <span class="token punctuation">(</span>email<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">INDEX</span> idx_created_at <span class="token punctuation">(</span>created_at<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个表中：</p><ul><li><code>id</code>是主键，对应聚簇索引</li><li><code>username</code>、<code>email</code>和<code>created_at</code>上的索引是非聚簇索引</li></ul><p>查询场景分析：</p><ol><li><p><code>SELECT * FROM users WHERE id = 1;</code></p><ul><li>直接使用聚簇索引，一次磁盘IO即可获取完整数据。</li></ul></li><li><p><code>SELECT * FROM users WHERE email = &#39;user@example.com&#39;;</code></p><ul><li>先通过非聚簇索引<code>idx_email</code>找到主键值</li><li>再通过主键值查询聚簇索引获取完整数据（回表）</li><li>需要两次索引查找</li></ul></li><li><p><code>SELECT id, email FROM users WHERE email = &#39;user@example.com&#39;;</code></p><ul><li>通过覆盖索引优化，只需要在<code>idx_email</code>索引中查找</li><li>不需要回表，因为索引包含了查询需要的所有列</li></ul></li></ol><h3 id="案例二-主键设计的影响" tabindex="-1"><a class="header-anchor" href="#案例二-主键设计的影响" aria-hidden="true">#</a> 案例二：主键设计的影响</h3><p>考虑两种不同的表设计：</p><p>设计A（自增主键）：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> orders <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    order_no <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">UNIQUE</span><span class="token punctuation">,</span>
    customer_id <span class="token keyword">INT</span><span class="token punctuation">,</span>
    order_date <span class="token keyword">DATETIME</span><span class="token punctuation">,</span>
    <span class="token keyword">INDEX</span> idx_order_no <span class="token punctuation">(</span>order_no<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">INDEX</span> idx_customer_id <span class="token punctuation">(</span>customer_id<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>设计B（业务字段作主键）：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> orders <span class="token punctuation">(</span>
    order_no <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    customer_id <span class="token keyword">INT</span><span class="token punctuation">,</span>
    order_date <span class="token keyword">DATETIME</span><span class="token punctuation">,</span>
    <span class="token keyword">INDEX</span> idx_customer_id <span class="token punctuation">(</span>customer_id<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分析：</p><ul><li>设计A使用自增主键，插入数据时主键值递增，新数据总是追加到索引末尾，减少了页分裂，提高了写入性能。</li><li>设计B使用业务字段<code>order_no</code>作为主键，随机的主键值会导致频繁的页分裂，降低写入性能。</li><li>设计A中查询<code>order_no</code>需要回表，设计B中直接使用聚簇索引。</li><li>设计A的主键占用空间小，二级索引叶子节点存储的主键值也小，节省空间。</li></ul><h2 id="总结-聚簇索引与非聚簇索引的区别" tabindex="-1"><a class="header-anchor" href="#总结-聚簇索引与非聚簇索引的区别" aria-hidden="true">#</a> 总结：聚簇索引与非聚簇索引的区别</h2><table><thead><tr><th>特性</th><th>聚簇索引</th><th>非聚簇索引</th></tr></thead><tbody><tr><td>数据存储</td><td>索引和数据存储在一起</td><td>索引和数据分开存储</td></tr><tr><td>叶子节点</td><td>包含完整的数据记录</td><td>包含主键值</td></tr><tr><td>数量限制</td><td>一个表只能有一个</td><td>一个表可以有多个</td></tr><tr><td>默认创建</td><td>主键自动成为聚簇索引</td><td>非主键索引都是非聚簇索引</td></tr><tr><td>查询路径</td><td>直接获取数据</td><td>需要回表（除非是覆盖索引）</td></tr><tr><td>维护成本</td><td>较高（页分裂、数据移动）</td><td>较低</td></tr><tr><td>适用场景</td><td>主键查询、范围查询</td><td>单列查询、复合条件查询</td></tr><tr><td>存储空间</td><td>不需要额外空间存储主键</td><td>需要额外空间存储主键</td></tr><tr><td>IO性能</td><td>查询通常只需一次IO</td><td>查询通常需要多次IO</td></tr></tbody></table><p>【聚簇索引结构】</p><div class="custom-container tip"><p class="custom-container-title">提示</p><p>待补充</p></div>`,33),i=[d];function l(o,p){return a(),s("div",null,i)}const u=n(t,[["render",l],["__file","MySQL InnoDB 引擎中的聚簇索引和非聚簇索引有什么区别.html.vue"]]);export{u as default};
